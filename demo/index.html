<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
    <title>MusicXML Player</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4a90e2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MusicPlayer">
    <meta name="description" content="A web-based MusicXML player with soundfont support">
    
    <!-- PWA Links -->
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    
    <!-- Splash Screen Images for iOS -->
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2048-2732.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2732-2048.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1668-2388.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2388-1668.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1536-2048.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2048-1536.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1668-2224.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2224-1668.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1620-2160.png" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2160-1620.png" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1290-2796.png" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2796-1290.png" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1179-2556.png" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2556-1179.png" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1284-2778.png" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2778-1284.png" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1170-2532.png" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2532-1170.png" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1125-2436.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2436-1125.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1242-2688.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-2688-1242.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-828-1792.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1792-828.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-750-1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1334-750.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-640-1136.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="/splash/apple-splash-1136-640.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>��</text></svg>">
    <style>
      :root {
        --primary-color: #4a90e2;
        --secondary-color: #f8f9fa;
        --text-color: #2c3e50;
        --border-radius: 8px;
        --player-height: 120px;
        --player-height-mobile: 160px;
      }

      body {
        background-color: var(--secondary-color);
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 20px;
        color: var(--text-color);
        min-height: 100vh;
        position: relative;
        padding-bottom: calc(var(--player-height) + 40px);
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
          padding-bottom: calc(var(--player-height-mobile) + 40px);
        }

        h1 {
          font-size: 1.8em !important;
          margin-bottom: 20px !important;
        }
      }

      .hide {
        display: none;
      }

      h1 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 30px;
        font-size: 2.5em;
      }

      .main-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      @media (max-width: 768px) {
        .main-container {
          padding: 10px;
        }
      }

      .controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      @media (max-width: 768px) {
        .controls-grid {
          grid-template-columns: 1fr;
          gap: 15px;
        }
      }

      .upload-section {
        background: white;
        padding: 20px;
        border-radius: var(--border-radius);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }

      .upload-section:hover {
        transform: translateY(-2px);
      }

      .upload-section h3 {
        margin: 0 0 15px 0;
        color: var(--primary-color);
        font-size: 1.2em;
      }

      input[type="file"] {
        width: 100%;
        padding: 10px;
        border: 2px dashed #ddd;
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        cursor: pointer;
      }

      input[type="file"]:hover {
        border-color: var(--primary-color);
      }

      select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        background: white;
        cursor: pointer;
      }

      #sheet-container {
        height: calc(100vh - var(--player-height) - 200px);
        margin: 10px 0;
        border-radius: var(--border-radius);
        background: white;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow-y: auto;
        padding: 20px;
        margin-bottom: 10px;
        -webkit-overflow-scrolling: touch;
      }

      @media (max-width: 768px) {
        #sheet-container {
          height: calc(100vh - var(--player-height-mobile) - 180px);
          padding: 10px;
          margin: 5px 0;
        }
      }

      #player {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        z-index: 1000;
        height: var(--player-height);
        display: flex;
        justify-content: center;
      }

      @media (max-width: 768px) {
        #player {
          height: var(--player-height-mobile);
          padding: 8px;
        }
      }

      .player-controls {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 15px;
        width: 100%;
        max-width: 1200px;
      }

      .playback-controls {
        display: flex;
        gap: 15px;
        align-items: center;
        flex: 1;
      }

      .controls-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .slider-control {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 150px;
      }

      .slider-control label {
        font-size: 0.85em;
        min-width: 60px;
      }

      .slider-control input[type="range"] {
        flex: 1;
      }

      .slider-control .value {
        font-size: 0.85em;
        min-width: 30px;
        text-align: right;
      }

      #instrumentSelector {
        width: 180px;
        font-size: 0.9em;
        padding: 4px;
      }

      .instrument-option {
        font-size: 0.9em;
        padding: 2px 4px;
      }

      .player {
        font-size: 18px;
        width: 36px;
        height: 36px;
      }

      .player#playPause {
        width: 42px;
        height: 42px;
        font-size: 20px;
      }

      .player#playPause[title="Stop"] {
        background-color: #e74c3c;
      }

      .player#playPause[title="Stop"]:hover {
        background-color: #c0392b;
      }

      .instrument-selector {
        min-width: 220px;
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 14px;
        color: var(--text-color);
        background: white;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .instrument-selector:hover {
        border-color: var(--primary-color);
      }

      .instrument-selector:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
      }

      #play {
        padding-left: 3px;
      }

      #pause {
        font-size: 18px;
      }

      #rewind {
        font-size: 16px;
      }

      #feedback, #pdf-feedback {
        margin-top: 10px;
        padding: 10px;
        border-radius: var(--border-radius);
        font-size: 0.9em;
      }

      .success { 
        color: #2ecc71;
        background: #e8f8f5;
      }

      .error { 
        color: #e74c3c;
        background: #fdedec;
      }

      .loading { 
        color: var(--primary-color);
        background: #eef7ff;
      }

      .spinner {
        border: 3px solid rgba(74, 144, 226, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: var(--primary-color);
        animation: spin 1s linear infinite;
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background 0.2s;
      }

      button:hover {
        background: #357abd;
      }

      .player-loading {
        position: relative;
      }

      .player-loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin: -8px 0 0 -8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      .player-loading.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .instrument-selector.loading {
        position: relative;
        pointer-events: none;
        opacity: 0.7;
      }
      .instrument-selector.loading::after {
        content: '';
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        border: 2px solid rgba(74, 144, 226, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 0.8s linear infinite;
      }

      /* Add these styles to the existing style section */
      .instrument-option {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 4px 8px;
      }

      .instrument-icon {
        font-size: 1.2em;
        min-width: 24px;
        text-align: center;
      }

      #instrumentSelector option {
        padding: 8px;
        font-size: 1em;
      }

      .instrument-group {
        font-weight: bold;
        background-color: #f5f5f5;
      }

      /* Add orientation specific styles */
      @media screen and (orientation: landscape) and (max-height: 600px) {
        #sheet-container {
          height: calc(100vh - var(--player-height) - 100px);
        }

        .player-controls {
          flex-direction: row;
          align-items: center;
        }

        .playback-controls {
          flex-direction: row;
          flex: 1;
        }

        #instrumentSelector {
          width: 160px;
        }
      }

      /* Improve visibility of music notation */
      @media (max-width: 768px) {
        #sheet-container svg {
          width: 100% !important;
          height: auto !important;
        }

        .system {
          transform-origin: left top;
          transform: scale(0.9);
        }
      }

      .controls-group {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .slider-control::before {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 4px;
        font-size: 12px;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        white-space: nowrap;
        pointer-events: none;
      }

      .slider-control:hover::before {
        opacity: 1;
        visibility: visible;
        bottom: calc(100% + 5px);
      }

      .slider-control input[type="range"].adjusting {
        background: var(--primary-color);
      }

      .slider-control input[type="range"].processing {
        opacity: 0.7;
        cursor: wait;
      }

      .slider-control input[type="range"].success {
        background: #2ecc71;
        transition: background 0.3s;
      }

      .slider-control input[type="range"].error {
        background: #e74c3c;
        transition: background 0.3s;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
      }

      .loading-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .loading-content {
        text-align: center;
        color: var(--primary-color);
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(74, 144, 226, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      .loading-text {
        font-size: 16px;
        margin-top: 10px;
      }

      .progress-bar {
        width: 200px;
        height: 4px;
        background: rgba(74, 144, 226, 0.2);
        border-radius: 2px;
        margin: 10px auto;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: var(--primary-color);
        width: 0%;
        transition: width 0.3s;
      }

      /* Enhanced tooltips for controls */
      [data-tooltip] {
        position: relative;
      }

      [data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
      }

      /* Status indicators */
      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-left: 5px;
        transition: all 0.3s;
      }

      .status-indicator.loading {
        background: var(--primary-color);
        animation: pulse 1s infinite;
      }

      .status-indicator.success {
        background: #2ecc71;
      }

      .status-indicator.error {
        background: #e74c3c;
      }

      @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.5; }
        100% { transform: scale(1); opacity: 1; }
      }

      .player {
        font-size: 22px;
        width: 44px;
        height: 44px;
        border: none;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        line-height: 1;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .player:hover {
        transform: scale(1.05);
        background: #357abd;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .player:active {
        transform: scale(0.95);
      }

      .player:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .player#playPause { 
        width: 52px;
        height: 52px;
        font-size: 24px;
      }

      .player#playPause[title="Stop"] {
        background-color: #e74c3c;
      }

      .player#playPause[title="Stop"]:hover {
        background-color: #c0392b;
      }

      .instrument-selector {
        min-width: 220px;
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 14px;
        color: var(--text-color);
        background: white;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .instrument-selector:hover {
        border-color: var(--primary-color);
      }

      .instrument-selector:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
      }

      #play {
        padding-left: 3px;
      }

      #pause {
        font-size: 18px;
      }

      #rewind {
        font-size: 16px;
      }

      #feedback, #pdf-feedback {
        margin-top: 10px;
        padding: 10px;
        border-radius: var(--border-radius);
        font-size: 0.9em;
      }

      .success { 
        color: #2ecc71;
        background: #e8f8f5;
      }

      .error { 
        color: #e74c3c;
        background: #fdedec;
      }

      .loading { 
        color: var(--primary-color);
        background: #eef7ff;
      }

      .spinner {
        border: 3px solid rgba(74, 144, 226, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: var(--primary-color);
        animation: spin 1s linear infinite;
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background 0.2s;
      }

      button:hover {
        background: #357abd;
      }

      .player-loading {
        position: relative;
      }

      .player-loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin: -8px 0 0 -8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      .player-loading.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .instrument-selector.loading {
        position: relative;
        pointer-events: none;
        opacity: 0.7;
      }
      .instrument-selector.loading::after {
        content: '';
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        border: 2px solid rgba(74, 144, 226, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 0.8s linear infinite;
      }

      /* Add these styles to the existing style section */
      .instrument-option {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 4px 8px;
      }

      .instrument-icon {
        font-size: 1.2em;
        min-width: 24px;
        text-align: center;
      }

      #instrumentSelector option {
        padding: 8px;
        font-size: 1em;
      }

      .instrument-group {
        font-weight: bold;
        background-color: #f5f5f5;
      }

      /* Add these styles for feedback and toast notifications */
      .feedback {
        margin-top: 10px;
        padding: 10px;
        border-radius: var(--border-radius);
        font-size: 0.9em;
        display: none;
      }

      .feedback.show {
        display: block;
      }

      .feedback.success {
        color: #2ecc71;
        background: #e8f8f5;
        border: 1px solid #2ecc71;
      }

      .feedback.error {
        color: #e74c3c;
        background: #fdedec;
        border: 1px solid #e74c3c;
      }

      .feedback.loading {
        color: var(--primary-color);
        background: #eef7ff;
        border: 1px solid var(--primary-color);
        display: flex;
        align-items: center;
      }

      .spinner {
        border: 2px solid rgba(74, 144, 226, 0.1);
        border-left-color: var(--primary-color);
        border-radius: 50%;
        width: 16px;
        height: 16px;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }

      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
      }

      .error-toast {
        display: flex;
        align-items: center;
        background: #ff5252;
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        margin-bottom: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        transform: translateX(100%);
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease;
      }

      .error-icon {
        margin-right: 12px;
        font-size: 20px;
      }

      .error-message {
        flex-grow: 1;
        margin-right: 12px;
      }

      .close-toast {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }

      .close-toast:hover {
        opacity: 0.8;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Navigation Menu Styles */
      .main-nav {
        margin-bottom: 30px;
      }

      .nav-menu {
        display: flex;
        list-style: none;
        padding: 0;
        margin: 0;
        background-color: #f8f9fa;
        border-radius: var(--border-radius);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .nav-item {
        flex: 1;
        text-align: center;
        transition: all 0.3s ease;
      }

      .nav-item a {
        display: block;
        padding: 15px 20px;
        color: var(--text-color);
        text-decoration: none;
        font-weight: 500;
        transition: all 0.3s ease;
      }

      .nav-item:hover {
        background-color: rgba(74, 144, 226, 0.1);
      }

      .nav-item:hover a {
        color: var(--primary-color);
      }

      .nav-item.active {
        background-color: var(--primary-color);
      }

      .nav-item.active a {
        color: white;
      }

      @media (max-width: 768px) {
        .nav-menu {
          flex-direction: column;
        }
        
        .nav-item {
          border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .nav-item:last-child {
          border-bottom: none;
        }
      }
    </style>
    <link rel="stylesheet" href="build/musicxml-player.css">
  </head>
  <body>
    <div class="loading-overlay">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
        <div class="progress-bar">
          <div class="progress-bar-fill"></div>
        </div>
      </div>
    </div>
    <div class="main-container">
      <h1>MusicXML Player</h1>
      
      <!-- Navigation Menu -->
      <nav class="main-nav">
        <ul class="nav-menu">
          <li class="nav-item active"><a href="index.html">Home</a></li>
          <li class="nav-item"><a href="midiano/index.html">MIDI Player</a></li>
        </ul>
      </nav>

      <div class="controls-grid">
        <div class="upload-section">
          <h3>Upload MusicXML File</h3>
          <input type="file" id="file-input" accept=".musicxml,.mxl,.xml"/>
          <div id="feedback" class="feedback"></div>
        </div>

        <div class="upload-section">
          <h3>Convert Score to MusicXML</h3>
          <input type="file" id="pdf-input" accept=".pdf,image/*" placeholder="Upload PDF or Image"/>
          <button id="convert-basic-btn" disabled>Convert Score</button>
          <div id="pdf-feedback" class="feedback"></div>
        </div>

        <div class="upload-section">
          <h3>Sample Scores</h3>
          <select id="samples">
            <option value="">-- Choose a sample --</option>
            <option value="data/asa-branca.musicxml">Asa Branca</option>
            <option value="data/bach-invention-1.musicxml">Bach Invention No. 1</option>
            <option value="data/chopin-prelude-20.musicxml">Chopin Prelude No. 20</option>
            <option value="data/debussy-clair-de-lune.musicxml">Debussy Clair de Lune</option>
          </select>
        </div>
      </div>

      <div id="sheet-container"></div>

      <div id="player">
        <div class="player-controls">
          <div class="playback-controls">
            <div class="controls-group">
              <button class="player" id="rewind" title="Rewind">⏮</button>
              <button class="player" id="play" title="Play">▶</button>
              <button class="player" id="pause" title="Pause">⏸</button>
            </div>
            <div class="slider-control" data-tooltip="Adjust playback speed">
              <label>Tempo (BPM)</label>
              <input type="range" id="tempoControl" min="40" max="208" value="120" step="1">
              <span class="value" id="tempoValue">120</span>
              <span class="status-indicator"></span>
            </div>
            <div class="slider-control" data-tooltip="Transpose the music up or down">
              <label>Transpose (semitones)</label>
              <input type="range" id="pitchControl" min="-12" max="12" value="0" step="1">
              <span class="value" id="pitchValue">0</span>
              <span class="status-indicator"></span>
            </div>
            <div class="slider-control" data-tooltip="Adjust reference pitch (A4)">
              <label>Pitch (Hz)</label>
              <input type="range" id="frequencyControl" min="380" max="480" value="440" step="1">
              <span class="value" id="frequencyValue">440</span>
              <span class="status-indicator"></span>
            </div>
          </div>
          <select id="instrumentSelector">
            <optgroup label="Piano">
              <option value="0" class="instrument-option">🎹 Acoustic Grand Piano</option>
              <option value="1" class="instrument-option">🎹 Bright Acoustic Piano</option>
              <option value="2" class="instrument-option">🎹 Electric Grand Piano</option>
              <option value="3" class="instrument-option">🎹 Honky-tonk Piano</option>
              <option value="4" class="instrument-option">🎹 Electric Piano 1</option>
              <option value="5" class="instrument-option">🎹 Electric Piano 2</option>
              <option value="6" class="instrument-option">🎹 Harpsichord</option>
              <option value="7" class="instrument-option">🎹 Clavinet</option>
            </optgroup>
            <optgroup label="Chromatic Percussion">
              <option value="8" class="instrument-option">🔔 Celesta</option>
              <option value="9" class="instrument-option">🔔 Glockenspiel</option>
              <option value="10" class="instrument-option">🎵 Music Box</option>
              <option value="11" class="instrument-option">🎵 Vibraphone</option>
              <option value="12" class="instrument-option">🎵 Marimba</option>
              <option value="13" class="instrument-option">🎵 Xylophone</option>
              <option value="14" class="instrument-option">🔔 Tubular Bells</option>
              <option value="15" class="instrument-option">🎵 Dulcimer</option>
            </optgroup>
            <optgroup label="Organ">
              <option value="16" class="instrument-option">🎹 Drawbar Organ</option>
              <option value="17" class="instrument-option">🎹 Percussive Organ</option>
              <option value="18" class="instrument-option">🎹 Rock Organ</option>
              <option value="19" class="instrument-option">🎹 Church Organ</option>
              <option value="20" class="instrument-option">🎹 Reed Organ</option>
              <option value="21" class="instrument-option">🪗 Accordion</option>
              <option value="22" class="instrument-option">🎵 Harmonica</option>
              <option value="23" class="instrument-option">🪗 Tango Accordion</option>
            </optgroup>
            <optgroup label="Guitar">
              <option value="24" class="instrument-option">🎸 Acoustic Guitar (Nylon)</option>
              <option value="25" class="instrument-option">🎸 Acoustic Guitar (Steel)</option>
              <option value="26" class="instrument-option">🎸 Electric Guitar (Jazz)</option>
              <option value="27" class="instrument-option">🎸 Electric Guitar (Clean)</option>
              <option value="28" class="instrument-option">🎸 Electric Guitar (Muted)</option>
              <option value="29" class="instrument-option">🎸 Overdriven Guitar</option>
              <option value="30" class="instrument-option">🎸 Distortion Guitar</option>
              <option value="31" class="instrument-option">🎸 Guitar Harmonics</option>
            </optgroup>
            <optgroup label="Bass">
              <option value="32" class="instrument-option">🎸 Acoustic Bass</option>
              <option value="33" class="instrument-option">🎸 Electric Bass (Finger)</option>
              <option value="34" class="instrument-option">🎸 Electric Bass (Pick)</option>
              <option value="35" class="instrument-option">🎸 Fretless Bass</option>
              <option value="36" class="instrument-option">🎸 Slap Bass 1</option>
              <option value="37" class="instrument-option">🎸 Slap Bass 2</option>
              <option value="38" class="instrument-option">🎸 Synth Bass 1</option>
              <option value="39" class="instrument-option">🎸 Synth Bass 2</option>
            </optgroup>
            <optgroup label="Strings">
              <option value="40" class="instrument-option">🎻 Violin</option>
              <option value="41" class="instrument-option">🎻 Viola</option>
              <option value="42" class="instrument-option">🎻 Cello</option>
              <option value="43" class="instrument-option">🎻 Contrabass</option>
              <option value="44" class="instrument-option">🎻 Tremolo Strings</option>
              <option value="45" class="instrument-option">🎻 Pizzicato Strings</option>
              <option value="46" class="instrument-option">🎵 Orchestral Harp</option>
              <option value="47" class="instrument-option">🥁 Timpani</option>
            </optgroup>
            <optgroup label="Ensemble">
              <option value="48" class="instrument-option">🎻 String Ensemble 1</option>
              <option value="49" class="instrument-option">🎻 String Ensemble 2</option>
              <option value="50" class="instrument-option">🎹 Synth Strings 1</option>
              <option value="51" class="instrument-option">🎹 Synth Strings 2</option>
              <option value="52" class="instrument-option">🎤 Choir Aahs</option>
              <option value="53" class="instrument-option">🎤 Voice Oohs</option>
              <option value="54" class="instrument-option">🎤 Synth Choir</option>
              <option value="55" class="instrument-option">🎵 Orchestra Hit</option>
            </optgroup>
            <optgroup label="Brass">
              <option value="56" class="instrument-option">🎺 Trumpet</option>
              <option value="57" class="instrument-option">🎺 Trombone</option>
              <option value="58" class="instrument-option">🎺 Tuba</option>
              <option value="59" class="instrument-option">🎺 Muted Trumpet</option>
              <option value="60" class="instrument-option">🎺 French Horn</option>
              <option value="61" class="instrument-option">🎺 Brass Section</option>
              <option value="62" class="instrument-option">🎹 Synth Brass 1</option>
              <option value="63" class="instrument-option">🎹 Synth Brass 2</option>
            </optgroup>
            <optgroup label="Reed">
              <option value="64" class="instrument-option">🎷 Soprano Sax</option>
              <option value="65" class="instrument-option">🎷 Alto Sax</option>
              <option value="66" class="instrument-option">🎷 Tenor Sax</option>
              <option value="67" class="instrument-option">🎷 Baritone Sax</option>
              <option value="68" class="instrument-option">🎵 Oboe</option>
              <option value="69" class="instrument-option">🎵 English Horn</option>
              <option value="70" class="instrument-option">🎵 Bassoon</option>
              <option value="71" class="instrument-option">🎵 Clarinet</option>
            </optgroup>
            <optgroup label="Pipe">
              <option value="72" class="instrument-option">🎵 Piccolo</option>
              <option value="73" class="instrument-option">🎵 Flute</option>
              <option value="74" class="instrument-option">🎵 Recorder</option>
              <option value="75" class="instrument-option">🎵 Pan Flute</option>
              <option value="76" class="instrument-option">🎵 Blown Bottle</option>
              <option value="77" class="instrument-option">🎵 Shakuhachi</option>
              <option value="78" class="instrument-option">🎵 Whistle</option>
              <option value="79" class="instrument-option">🎵 Ocarina</option>
            </optgroup>
            <optgroup label="Synth Lead">
              <option value="80" class="instrument-option">🎹 Lead 1 (Square)</option>
              <option value="81" class="instrument-option">🎹 Lead 2 (Sawtooth)</option>
              <option value="82" class="instrument-option">🎹 Lead 3 (Calliope)</option>
              <option value="83" class="instrument-option">🎹 Lead 4 (Chiff)</option>
              <option value="84" class="instrument-option">🎹 Lead 5 (Charang)</option>
              <option value="85" class="instrument-option">🎹 Lead 6 (Voice)</option>
              <option value="86" class="instrument-option">🎹 Lead 7 (Fifths)</option>
              <option value="87" class="instrument-option">🎹 Lead 8 (Bass + Lead)</option>
            </optgroup>
            <optgroup label="Synth Pad">
              <option value="88" class="instrument-option">🎹 Pad 1 (New Age)</option>
              <option value="89" class="instrument-option">🎹 Pad 2 (Warm)</option>
              <option value="90" class="instrument-option">🎹 Pad 3 (Polysynth)</option>
              <option value="91" class="instrument-option">🎹 Pad 4 (Choir)</option>
              <option value="92" class="instrument-option">🎹 Pad 5 (Bowed)</option>
              <option value="93" class="instrument-option">🎹 Pad 6 (Metallic)</option>
              <option value="94" class="instrument-option">🎹 Pad 7 (Halo)</option>
              <option value="95" class="instrument-option">🎹 Pad 8 (Sweep)</option>
            </optgroup>
            <optgroup label="Synth Effects">
              <option value="96" class="instrument-option">🎹 FX 1 (Rain)</option>
              <option value="97" class="instrument-option">🎹 FX 2 (Soundtrack)</option>
              <option value="98" class="instrument-option">🎹 FX 3 (Crystal)</option>
              <option value="99" class="instrument-option">🎹 FX 4 (Atmosphere)</option>
              <option value="100" class="instrument-option">🎹 FX 5 (Brightness)</option>
              <option value="101" class="instrument-option">🎹 FX 6 (Goblins)</option>
              <option value="102" class="instrument-option">🎹 FX 7 (Echoes)</option>
              <option value="103" class="instrument-option">🎹 FX 8 (Sci-Fi)</option>
            </optgroup>
            <optgroup label="Ethnic">
              <option value="104" class="instrument-option">🎸 Sitar</option>
              <option value="105" class="instrument-option">🎸 Banjo</option>
              <option value="106" class="instrument-option">🎸 Shamisen</option>
              <option value="107" class="instrument-option">🎸 Koto</option>
              <option value="108" class="instrument-option">🎵 Kalimba</option>
              <option value="109" class="instrument-option">🎵 Bagpipe</option>
              <option value="110" class="instrument-option">🎻 Fiddle</option>
              <option value="111" class="instrument-option">🎵 Shanai</option>
            </optgroup>
            <optgroup label="Percussive">
              <option value="112" class="instrument-option">🔔 Tinkle Bell</option>
              <option value="113" class="instrument-option">🔔 Agogo</option>
              <option value="114" class="instrument-option">🥁 Steel Drums</option>
              <option value="115" class="instrument-option">🥁 Woodblock</option>
              <option value="116" class="instrument-option">🥁 Taiko Drum</option>
              <option value="117" class="instrument-option">🥁 Melodic Tom</option>
              <option value="118" class="instrument-option">🥁 Synth Drum</option>
              <option value="119" class="instrument-option">🔔 Reverse Cymbal</option>
            </optgroup>
            <optgroup label="Sound Effects">
              <option value="120" class="instrument-option">🎸 Guitar Fret Noise</option>
              <option value="121" class="instrument-option">🌬️ Breath Noise</option>
              <option value="122" class="instrument-option">🌊 Seashore</option>
              <option value="123" class="instrument-option">🐦 Bird Tweet</option>
              <option value="124" class="instrument-option">📞 Telephone Ring</option>
              <option value="125" class="instrument-option">🚁 Helicopter</option>
              <option value="126" class="instrument-option">👏 Applause</option>
              <option value="127" class="instrument-option">💥 Gunshot</option>
            </optgroup>
          </select>
        </div>
      </div>
    </div>

    <!-- Add unzip library -->
    <script src="https://unpkg.com/unzipit@1.4.3/dist/unzipit.min.js"></script>
    <script type="module">
      // Add ApiService class before other code
      class ApiService {
        static async isPdfEncrypted(file) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = function(e) {
              const buffer = e.target.result;
              const content = new Uint8Array(buffer);
              
              // First check if it's a valid PDF
              const pdfHeader = content.slice(0, 8);
              const decoder = new TextDecoder();
              const headerText = decoder.decode(pdfHeader);
              if (!headerText.startsWith('%PDF-')) {
                  resolve(false);
                  return;
              }

              // Convert a portion for checking
              const portion = content.slice(0, Math.min(2048, content.byteLength));
              const text = decoder.decode(portion);

              // Core encryption patterns that definitely indicate encryption
              const encryptionPatterns = [
                  // Standard encryption dictionary with object reference
                  /\/Encrypt\s+\d+\s+\d+\s+R/i,
                  // Direct encryption dictionary
                  /\/Encrypt\s*<<[^>]*\/Filter/i,
                  // Password protection
                  /\/Password|\/EncryptMetadata\s+true/i,
                  // Standard security handler with encryption
                  /\/Filter\s*\/Standard\s*\/V\s*[1-5]/i,
                  // Strong encryption indicators
                  /\/StmF\s*\/StdCF|\/StrF\s*\/StdCF/i
              ];

              // Check for definitive encryption patterns
              const hasEncryptionMarkers = encryptionPatterns.some(pattern => pattern.test(text));
              
              // Only mark as encrypted if we find clear encryption markers
              resolve(hasEncryptionMarkers);
            };

            reader.onerror = function() {
              // If we can't read the file, assume it's not encrypted
              resolve(false);
            };

            // Read just the first portion of the file
            const slice = file.slice(0, Math.min(file.size, 2048));
            reader.readAsArrayBuffer(slice);
          });
        }

        static async checkHealth() {
          try {
            const response = await fetch('http://ec2-54-252-145-103.ap-southeast-2.compute.amazonaws.com:8000/health');
            if (!response.ok) {
              throw new Error(`Server health check failed: ${response.status}`);
            }
            return true;
          } catch (error) {
            console.error('Health check failed:', error);
            throw new Error('Server is not responding. Please try again later.');
          }
        }
      }

      import {
        Player,
        VerovioConverter,
        VerovioRenderer,
        SoundFontOutput
      } from './build/musicxml-player.mjs';

      // Initialize control variables first
      const tempoControl = document.getElementById('tempoControl');
      const tempoValue = document.getElementById('tempoValue');
      const pitchControl = document.getElementById('pitchControl');
      const pitchValue = document.getElementById('pitchValue');
      const frequencyControl = document.getElementById('frequencyControl');
      const frequencyValue = document.getElementById('frequencyValue');
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      const rewindBtn = document.getElementById('rewind');

      // Global state variables
      let currentPlayer = null;
      let currentMusicXml = null;
      let currentOutput = null;
      let isProcessing = false;
      let isLoadingSoundFont = false;
      let audioContext = null;
      let soundFontLoaded = false;
      let currentInstrumentId = null;
      let playbackInterval = null;
      let currentPitchSettings = {
        semitones: 0,
        frequency: 440
      };

      // Initialize default control values
      if (tempoControl) {
        tempoControl.value = "120";
        tempoValue.textContent = "120";
      }
      if (pitchControl) {
        pitchControl.value = "0";
        pitchValue.textContent = "0";
      }
      if (frequencyControl) {
        frequencyControl.value = "440";
        frequencyValue.textContent = "440";
      }

      // Initial button state
      console.log('Initial page load: Setting default button state.');
      if (playBtn) playBtn.disabled = false;
      if (pauseBtn) pauseBtn.disabled = true;
      if (rewindBtn) rewindBtn.disabled = false;

      // ... rest of the existing code ...

      // Loading overlay management
      const loadingOverlay = {
        overlay: document.querySelector('.loading-overlay'),
        text: document.querySelector('.loading-text'),
        progress: document.querySelector('.progress-bar-fill'),
        
        show(message = 'Loading...') {
          this.text.textContent = message;
          this.progress.style.width = '0%';
          this.overlay.classList.add('active');
        },
        
        hide() {
          this.overlay.classList.remove('active');
        },
        
        setProgress(percent) {
          this.progress.style.width = `${percent}%`;
        },
        
        updateMessage(message) {
          this.text.textContent = message;
        }
      };

      // Function to show loading state on a button
      function setButtonLoading(button, isLoading) {
        if (isLoading) {
          button.classList.add('player-loading');
          button.disabled = true;  // Disable button while loading
        } else {
          button.classList.remove('player-loading');
          button.disabled = false; // Re-enable button after loading
        }
      }

      // Function to show loading state on instrument selector
      function setInstrumentSelectorLoading(isLoading) {
        const selector = document.getElementById('instrumentSelector');
        if (isLoading) {
          selector.classList.add('loading');
          selector.disabled = true;
        } else {
          selector.classList.remove('loading');
          selector.disabled = false;
        }
      }

      // Function to check if pitch settings have changed
      function havePitchSettingsChanged(newSemitones, newFrequency) {
        return currentPitchSettings.semitones !== newSemitones || 
               currentPitchSettings.frequency !== newFrequency;
      }

      // Function to initialize or reinitialize SoundFont
      async function initializeSoundFont(instrumentId, force = false) {
        if (!force && soundFontLoaded && instrumentId === currentInstrumentId) {
          console.log('[initializeSoundFont] SoundFont already loaded for instrument:', instrumentId);
          return;
        }

        isLoadingSoundFont = true;
        setInstrumentSelectorLoading(true);  // Show loading state on selector
        
        try {
          console.log('[initializeSoundFont] Initializing SoundFont for instrument:', instrumentId);

          // Initialize audio context if needed
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          // Resume audio context if suspended
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          // Clean up previous output
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.reset === 'function') {
                await currentOutput.reset();
              }
              if (typeof currentOutput.destroy === 'function') {
                await currentOutput.destroy();
              }
            } catch (e) {
              console.warn('Error cleaning up previous output:', e);
            }
            currentOutput = null;
          }

          // Create new output with selected instrument
          const midiJson = {
            division: 480,
            tracks: [[{
              channel: 0,
              programChange: {
                programNumber: parseInt(instrumentId)
              }
            }]]
          };

          currentOutput = new SoundFontOutput(midiJson);
          await currentOutput.initialize();
          soundFontLoaded = true;
          currentInstrumentId = instrumentId;
          console.log('[initializeSoundFont] SoundFont initialized successfully');
        } catch (e) {
          console.error('Error initializing SoundFont:', e);
          currentOutput = null;
          soundFontLoaded = false;
          currentInstrumentId = null;
          throw e;
        } finally {
          isLoadingSoundFont = false;
          setInstrumentSelectorLoading(false);  // Hide loading state on selector
        }
      }

      // Add state tracking
      let activeIntervals = new Map();
      let currentWorker = null;
      let workerInterval = null;
      let isCleaningUp = false;

      // Function to safely clear interval and worker
      function clearPlaybackInterval() {
        try {
          // Clear the actual interval if it exists
          if (workerInterval) {
            clearInterval(workerInterval);
            workerInterval = null;
          }

          // Stop and cleanup the worker
          if (currentWorker) {
            try {
              currentWorker.postMessage({ type: 'stop' });
              currentWorker.terminate();
            } catch (e) {
              console.warn('[clearPlaybackInterval] Error terminating worker:', e);
            }
            currentWorker = null;
          }

          // Clear tracking
          activeIntervals.clear();
          playbackInterval = null;
          
          console.log('[clearPlaybackInterval] Cleared interval and worker');
        } catch (e) {
          console.warn('[clearPlaybackInterval] Error during cleanup:', e);
        }
      }

      // Enhanced cleanup function
      async function cleanupPlayer() {
        if (isCleaningUp) return;
        isCleaningUp = true;
        
        try {
          clearPlaybackInterval();

          if (currentPlayer) {
            try {
              // First try to pause any ongoing playback
              if (typeof currentPlayer.pause === 'function') {
                await currentPlayer.pause();
              }

              // Clear the sheet container before destroying the player
              const container = document.getElementById('sheet-container');
              if (container) {
                container.innerHTML = '';
              }

              // Then try to destroy the player
              if (typeof currentPlayer.destroy === 'function') {
                await currentPlayer.destroy();
              }
            } catch (e) {
              console.warn('[cleanupPlayer] Error cleaning up player:', e);
            }
            currentPlayer = null;
          }

          // Clean up audio context if needed
          if (audioContext && audioContext.state === 'running') {
            try {
              await audioContext.suspend();
            } catch (e) {
              console.warn('[cleanupPlayer] Error suspending audio context:', e);
            }
          }

          // Clean up output if available
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.reset === 'function') {
                await currentOutput.reset();
              }
              if (typeof currentOutput.destroy === 'function') {
                await currentOutput.destroy();
              }
            } catch (e) {
              console.warn('[cleanupPlayer] Error cleaning up output:', e);
            }
            currentOutput = null;
          }
        } finally {
          isCleaningUp = false;
        }
      }

      // Function to safely handle player state changes
      async function safePlayerStateChange(action) {
        if (!currentPlayer) return false;
        
        try {
          if (typeof currentPlayer[action] === 'function') {
            await currentPlayer[action]();
            return true;
          } else {
            console.warn(`[safePlayerStateChange] ${action} is not a function`);
            // Fallback behaviors for missing methods
            if (action === 'stop') {
              if (typeof currentPlayer.pause === 'function') {
                await currentPlayer.pause();
                if (typeof currentPlayer.seek === 'function') {
                  await currentPlayer.seek(0);
                }
                return true;
              }
            }
            return false;
          }
        } catch (e) {
          console.warn(`[safePlayerStateChange] Error during ${action}:`, e);
          return false;
        }
      }

      // Function to safely initialize audio context
      async function initializeAudioContext() {
        try {
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          return true;
        } catch (e) {
          console.error('Error initializing audio context:', e);
          loadingOverlay.updateMessage('Error initializing audio. Please reload the page.');
          return false;
        }
      }

      // Enhanced createNewPlayer with better instrument handling
      async function createNewPlayer(musicXmlData, selectedInstrumentId = null) {
        loadingOverlay.show('Initializing player...');
        
        if (!musicXmlData) {
          loadingOverlay.hide();
          throw new Error('No MusicXML data provided');
        }

        currentMusicXml = musicXmlData;
        
        try {
          loadingOverlay.setProgress(20);
          loadingOverlay.updateMessage('Clearing previous state...');
          
          // Clean up previous state
          await cleanupPlayer();

          // Only initialize audio context if we have a selected instrument
          // This allows loading the score without starting audio
          if (selectedInstrumentId) {
            loadingOverlay.setProgress(40);
            loadingOverlay.updateMessage('Initializing audio...');
            
            // Initialize audio context
            const audioContextReady = await initializeAudioContext();
            if (!audioContextReady) {
              throw new Error('Failed to initialize audio context');
            }

            // Initialize SoundFont if instrument is selected
            loadingOverlay.updateMessage('Loading instrument sounds...');
            await initializeSoundFont(selectedInstrumentId, true);
          }

          loadingOverlay.setProgress(80);
          loadingOverlay.updateMessage('Creating player...');
          
          // Create player with current output
          const player = await Player.create({
            container: 'sheet-container',
            musicXml: musicXmlData,
            renderer: new VerovioRenderer(),
            converter: new VerovioConverter(),
            output: currentOutput,
            audioContext: audioContext
          });

          currentPlayer = player;

          // Only apply audio settings if we have an instrument selected
          if (selectedInstrumentId) {
            loadingOverlay.setProgress(90);
            loadingOverlay.updateMessage('Applying settings...');
            
            try {
              const tempo = tempoControl.value;
              const semitones = parseInt(pitchControl.value);
              const frequency = parseInt(frequencyControl.value);
              
              if (havePitchSettingsChanged(semitones, frequency)) {
                const combinedPitch = Math.pow(2, (semitones + (frequency - 440) / 12) / 12);
                currentPlayer.pitch = combinedPitch;
                currentPitchSettings.semitones = semitones;
                currentPitchSettings.frequency = frequency;
              }
              
              currentPlayer.tempo = tempo / 120;
            } catch (e) {
              console.warn('Error applying settings:', e);
            }
          }

          loadingOverlay.setProgress(100);
          loadingOverlay.updateMessage('Ready!');
          setTimeout(() => loadingOverlay.hide(), 500);
          
          return player;
        } catch (error) {
          console.error('Error creating player:', error);
          loadingOverlay.updateMessage(`Error: ${error.message}`);
          setTimeout(() => loadingOverlay.hide(), 2000);
          
          const feedback = document.getElementById('feedback');
          if (feedback) {
            feedback.className = 'error';
            feedback.textContent = `Error: ${error.message || 'Failed to create player'}`;
          }
          
          // Clean up on error
          await cleanupPlayer();
          
          // Reset to default state
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
          
          throw error;
        }
      }

      // Function to handle file selection
      async function handleFileSelect(e) {
        const file = e.target.files[0];
        if (!file) return;

        showFeedback('feedback', 'Processing file...', 'loading');

        try {
          // Check file size
          if (file.size > 4 * 1024 * 1024) {
            throw new Error('File too large. Maximum size is 4MB.');
          }

          const buffer = await file.arrayBuffer();
          
          // Check if it's an MXL file (ZIP format)
          const isZip = file.name.toLowerCase().endsWith('.mxl') || 
                        (new Uint8Array(buffer.slice(0, 2)).toString() === '80,75');

          let musicXmlText;
          if (isZip) {
            showFeedback('feedback', 'Extracting compressed MusicXML...', 'loading');
            
            try {
              const { entries } = await window.unzipit.unzip(buffer);
              
              // First try to find the rootfile from container.xml
              let rootFile;
              if (entries['META-INF/container.xml']) {
                const containerXml = await entries['META-INF/container.xml'].text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(containerXml, 'text/xml');
                rootFile = doc.querySelector('rootfile')?.getAttribute('full-path');
              }
              
              if (rootFile && entries[rootFile]) {
                musicXmlText = await entries[rootFile].text();
              } else {
                // Look for any .xml file
                const xmlFiles = Object.keys(entries).filter(name => name.toLowerCase().endsWith('.xml'));
                if (xmlFiles.length > 0) {
                  musicXmlText = await entries[xmlFiles[0]].text();
                } else {
                  throw new Error('No MusicXML file found in the MXL archive');
                }
              }

              if (!musicXmlText?.trim()) {
                throw new Error('Extracted MusicXML is empty');
              }
              
            } catch (error) {
              throw new Error(`Failed to extract MXL file: ${error.message}`);
            }
          } else {
            try {
              musicXmlText = new TextDecoder().decode(buffer);
              const parser = new DOMParser();
              const doc = parser.parseFromString(musicXmlText, 'text/xml');
              if (doc.querySelector('parsererror')) {
                throw new Error('Invalid XML format');
              }
            } catch (error) {
              throw new Error(`Invalid MusicXML format: ${error.message}`);
            }
          }

          // Create player with default output
          await createNewPlayer(musicXmlText);
          
          showFeedback('feedback', 'Score loaded successfully! Ready to play.', 'success');

        } catch (error) {
          console.error('File processing error:', error);
          showFeedback('feedback', `Error: ${error.message}`, 'error');
          showError(error.message);
          currentMusicXml = null;
        }

        // Reset file input
        e.target.value = '';
      }

      // Function to handle PDF uploads and conversion
      async function convertPdfToMusicXml(pdfFile) {
        const feedback = document.getElementById('pdf-feedback');
        const basicBtn = document.getElementById('convert-basic-btn');

        if (!pdfFile) {
          feedback.className = 'error';
          feedback.textContent = 'Please select a PDF or image file first.';
          return;
        }

        // Basic Conversion Call
        basicBtn.onclick = async () => {
          const formData = new FormData();
          formData.append('file', pdfFile);
          formData.append('filename', pdfFile.name);
          formData.append('filetype', pdfFile.type);

          feedback.className = 'loading';
          feedback.innerHTML = '<span class="spinner"></span> Converting PDF to MusicXML...';
          basicBtn.disabled = true;

          try {
            // First validate the file
            if (!pdfFile.type.includes('pdf') && !pdfFile.type.includes('image')) {
              throw new Error('Please upload a PDF or image file.');
            }

            // Make the API call to convert
            const response = await fetch('http://ec2-54-252-145-103.ap-southeast-2.compute.amazonaws.com:8000/convert', {
              method: 'POST',
              body: formData,
              headers: {
                'Accept': 'application/xml, application/x-zip'
              }
            });

            if (!response.ok) {
              let errorMsg = `Conversion failed! Status: ${response.status}`;
              try {
                const errData = await response.json();
                errorMsg = errData.detail || errorMsg;
              } catch (e) {
                console.warn('Error parsing error response:', e);
              }
              throw new Error(errorMsg);
            }

            const contentType = response.headers.get('Content-Type');
            const blob = await response.blob();
            
            let musicXmlText = '';

            // Handle different response types
            if (contentType?.includes('zip') || contentType?.includes('mxl') || 
                (blob.size > 0 && (await blob.slice(0, 2).text()) === 'PK')) {
              console.log('Processing MXL/ZIP response...');
              
              try {
                const { entries } = await window.unzipit.unzip(blob);
                console.log('ZIP entries:', Object.keys(entries));

                // Try to find the main MusicXML file
                let musicXmlEntry;

                // First check container.xml if it exists
                if (entries['META-INF/container.xml']) {
                  const containerText = await entries['META-INF/container.xml'].text();
                  const parser = new DOMParser();
                  const containerDoc = parser.parseFromString(containerText, 'application/xml');
                  const rootfilePath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
                  
                  if (rootfilePath && entries[rootfilePath]) {
                    musicXmlEntry = entries[rootfilePath];
                  }
                }

                // Fallback: look for any .musicxml or .xml file
                if (!musicXmlEntry) {
                  musicXmlEntry = Object.values(entries).find(entry => 
                    entry.name.endsWith('.musicxml') || entry.name.endsWith('.xml')
                  );
                }

                if (!musicXmlEntry) {
                  throw new Error('No MusicXML file found in the converted package');
                }

                musicXmlText = await musicXmlEntry.text();
                console.log('Successfully extracted MusicXML from package');

              } catch (zipError) {
                console.error('Error processing MXL/ZIP:', zipError);
                throw new Error(`Failed to process converted file: ${zipError.message}`);
              }
            } else {
              // Assume direct MusicXML response
              musicXmlText = await blob.text();
            }

            // Validate the MusicXML
            if (!musicXmlText.trim().startsWith('<?xml') || !musicXmlText.includes('<score-partwise')) {
              throw new Error('Invalid MusicXML received from conversion');
            }

            feedback.textContent = 'Conversion successful! Loading score...';
            
            // Get current instrument selection
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector.value;
            
            // Create new player with the converted MusicXML and selected instrument
            await createNewPlayer(musicXmlText, selectedInstrumentId || null);
            
            feedback.className = 'success';
            feedback.textContent = 'PDF successfully converted and loaded!';

          } catch (error) {
            console.error('PDF conversion error:', error);
            feedback.className = 'error';
            feedback.textContent = `Conversion failed: ${error.message}`;
          } finally {
            basicBtn.disabled = false;
          }
        };
      }

      // Function to clear all feedback messages
      function clearAllFeedback() {
        const feedbacks = ['feedback', 'pdf-feedback'];
        feedbacks.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.textContent = '';
            element.className = '';
          }
        });
      }

      // Update sample selector handler
      document.getElementById('samples').addEventListener('change', async (event) => {
        const sample = event.target.value;
        if (sample) {
          clearAllFeedback(); // Clear previous messages
          const feedback = document.getElementById('feedback');
          feedback.className = 'loading';
          feedback.textContent = 'Loading sample...';
          
          try {
            const response = await fetch(sample);
            const content = await response.text();
            await createNewPlayer(content);
            
            feedback.className = 'success';
            feedback.textContent = 'Sample score loaded successfully!';
            
            // Clear any PDF upload state
            document.getElementById('pdf-input').value = '';
          } catch (error) {
            console.error('Error loading sample:', error);
            feedback.className = 'error';
            feedback.textContent = 'Error loading sample score.';
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
          }
        }
      });

      // Update file input handler
      document.getElementById('file-input').addEventListener('change', handleFileSelect);

      // Update PDF file input handler
      document.getElementById('pdf-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        const feedback = document.getElementById('pdf-feedback');
        const basicBtn = document.getElementById('convert-basic-btn');

        clearAllFeedback(); // Clear previous messages

        if (file) {
          // Validate file type
          if (!file.type.includes('pdf') && !file.type.includes('image')) {
            feedback.className = 'error';
            feedback.textContent = 'Please select a PDF or image file of sheet music.';
            basicBtn.disabled = true;
            return;
          }

          feedback.className = 'info';
          feedback.textContent = `Selected: ${file.name}`;
          convertPdfToMusicXml(file);
          basicBtn.disabled = false;

          // Clear other inputs
          document.getElementById('file-input').value = '';
          document.getElementById('samples').value = '';
        } else {
          feedback.textContent = '';
          basicBtn.disabled = true;
          convertPdfToMusicXml(null);
        }
      });

      // Update default sample loading
      async function loadDefaultSample() {
        try {
          const response = await fetch('data/asa-branca.musicxml');
          const content = await response.text();
          
          // Create player without initializing audio context
          await createNewPlayer(content);
          
          const feedback = document.getElementById('feedback');
          feedback.className = 'success';
          feedback.textContent = 'Default score loaded successfully! Click play to start.';
          
          // Update the samples dropdown to show the current selection
          const samplesSelect = document.getElementById('samples');
          samplesSelect.value = 'data/asa-branca.musicxml';
        } catch (error) {
          console.error('Error loading default sample:', error);
          const feedback = document.getElementById('feedback');
          feedback.className = 'error';
          feedback.textContent = 'Error loading default score. Please try uploading your own file.';
          currentMusicXml = null;
        }
      }

      // Load default sample without creating player
      loadDefaultSample();

      // Set up control button event listeners
      playBtn.addEventListener('click', playMusic);
      pauseBtn.addEventListener('click', pauseMusic);
      rewindBtn.addEventListener('click', rewind);

      // Initial button state
      console.log('Initial page load: Setting default button state.');
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      rewindBtn.disabled = false;

      // Function to set up playback interval
      function setPlaybackInterval(callback, delay) {
        clearPlaybackInterval(); // Clean up existing interval and worker
        
        try {
          // Create a simple interval
          workerInterval = setInterval(() => {
            try {
              callback();
            } catch (error) {
              console.warn('[playbackInterval] Error in interval callback:', error);
              clearPlaybackInterval();
            }
          }, delay);
          
          // Use a simple number for interval tracking
          const intervalId = Date.now();
          activeIntervals.set(intervalId, true);
          playbackInterval = intervalId;
          
          return intervalId;
        } catch (e) {
          console.warn('[setPlaybackInterval] Error setting up interval:', e);
          clearPlaybackInterval();
          return null;
        }
      }

      // Tempo control handler
      tempoControl.addEventListener('input', async (event) => {
        const tempo = parseFloat(event.target.value);
        tempoValue.textContent = tempo;
        
        if (!currentPlayer) return;

        try {
          // Store current state
          const wasPlaying = currentPlayer.state === 1; // 1 = PlayerState.Playing
          const currentPosition = currentPlayer.position || 0;

          // Calculate new velocity
          const newVelocity = tempo / 120;

          if (wasPlaying) {
            // If playing, we need to pause, update tempo, and resume
            await currentPlayer.pause();
            
            // Clear any pending sounds
            if (currentOutput) {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            }

            // Update velocity
            currentPlayer.velocity = newVelocity;

            // Small delay to ensure changes take effect
            await new Promise(resolve => setTimeout(resolve, 30));

            // Resume from current position
            if (currentPosition > 0 && typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(currentPosition);
            }
            await currentPlayer.play();
          } else {
            // If not playing, reinitialize the player with new tempo
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector.value || '0';
            
            // Store current position
            const position = currentPlayer.position || 0;
            
            // Clean up current state
            await cleanupPlayer();
            
            // Initialize new player with current settings
            await initializeSoundFont(selectedInstrumentId, true);
            await createNewPlayer(currentMusicXml, selectedInstrumentId);
            
            // Apply tempo and restore position
            currentPlayer.velocity = newVelocity;
            if (position > 0 && typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(position);
            }
          }
        } catch (error) {
          console.error('Error updating tempo:', error);
          // Try to recover the player state
          try {
            if (currentPlayer && currentPlayer.state === 1) {
              await currentPlayer.play();
            }
          } catch (e) {
            console.warn('Failed to recover player state:', e);
          }
        }
      });

      // Update playMusic function to handle tempo changes
      async function playMusic() {
        console.log('[playMusic] Called. Current state:', currentPlayer?.state);
        
        try {
          if (playBtn) setButtonLoading(playBtn, true);

          // Initialize audio context if needed
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          // Resume audio context if suspended
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          // If we have currentMusicXml but no player, create one
          if (currentMusicXml && !currentPlayer) {
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector?.value || '0';
            
            // Initialize SoundFont and create player
            await initializeSoundFont(selectedInstrumentId, true);
            await createNewPlayer(currentMusicXml, selectedInstrumentId);
          }

          if (!currentPlayer || (isProcessing && !isLoadingSoundFont)) {
            console.log('[playMusic] Aborted (no player or processing).');
            return;
          }

          clearPlaybackInterval();

          // Ensure current tempo and pitch settings are applied
          if (tempoControl && currentPlayer) {
            const tempo = parseFloat(tempoControl.value) || 120;
            currentPlayer.velocity = tempo / 120;
          }

          if (pitchControl && frequencyControl && currentPlayer) {
            const semitones = parseInt(pitchControl.value) || 0;
            const frequency = parseInt(frequencyControl.value) || 440;
            const combinedPitch = Math.pow(2, (semitones + (frequency - 440) / 12) / 12);
            currentPlayer.pitch = combinedPitch;
          }

          // Stop any current sounds and clear audio buffers
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            } catch (e) {
              console.warn('[playMusic] Error clearing audio:', e);
            }
          }

          // Disable controls during playback
          if (playBtn) playBtn.disabled = true;
          if (pauseBtn) pauseBtn.disabled = false;
          if (rewindBtn) rewindBtn.disabled = false;
          if (tempoControl) {
            tempoControl.disabled = true;
            tempoControl.style.opacity = '0.5';
          }
          if (pitchControl) {
            pitchControl.disabled = true;
            pitchControl.style.opacity = '0.5';
          }
          if (frequencyControl) {
            frequencyControl.disabled = true;
            frequencyControl.style.opacity = '0.5';
          }

          // Small delay to ensure audio buffers are cleared
          await new Promise(resolve => setTimeout(resolve, 50));

          // Always start from current position
          const currentPosition = currentPlayer.position || 0;
          if (typeof currentPlayer.seek === 'function') {
            await currentPlayer.seek(currentPosition);
          }
          await safePlayerStateChange('play');

          // Set up interval with improved error handling
          setPlaybackInterval(() => {
            if (currentPlayer && currentPlayer.state === 1) {
              if (currentPlayer.currentTime >= currentPlayer.duration) {
                clearPlaybackInterval();
                safePlayerStateChange('stop');
                if (playBtn) playBtn.disabled = false;
                if (pauseBtn) pauseBtn.disabled = true;
                if (rewindBtn) rewindBtn.disabled = false;
                if (tempoControl) {
                  tempoControl.disabled = false;
                  tempoControl.style.opacity = '1';
                }
                if (pitchControl) {
                  pitchControl.disabled = false;
                  pitchControl.style.opacity = '1';
                }
                if (frequencyControl) {
                  frequencyControl.disabled = false;
                  frequencyControl.style.opacity = '1';
                }
                console.log('[playMusic] Playback completed');
              }
            }
          }, 100);
          
          console.log('[playMusic] Play/Resume successful. New state:', currentPlayer?.state);
        } catch (error) {
          console.error('Error playing music:', error);
          clearPlaybackInterval();
          if (playBtn) playBtn.disabled = false;
          if (pauseBtn) pauseBtn.disabled = true;
          if (rewindBtn) rewindBtn.disabled = false;
          if (tempoControl) {
            tempoControl.disabled = false;
            tempoControl.style.opacity = '1';
          }
          if (pitchControl) {
            pitchControl.disabled = false;
            pitchControl.style.opacity = '1';
          }
          if (frequencyControl) {
            frequencyControl.disabled = false;
            frequencyControl.style.opacity = '1';
          }
        } finally {
          if (playBtn) setButtonLoading(playBtn, false);
        }
      }

      // Update pauseMusic function
      async function pauseMusic() {
        console.log('[pauseMusic] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer || currentPlayer.state !== 1) {
          console.log('[pauseMusic] Aborted (no player or not playing).');
          return;
        }

        try {
          setButtonLoading(pauseBtn, true);
          clearPlaybackInterval();

          // Re-enable all controls when paused
          if (playBtn) playBtn.disabled = false;
          if (pauseBtn) pauseBtn.disabled = true;
          if (rewindBtn) rewindBtn.disabled = false;
          if (tempoControl) {
            tempoControl.disabled = false;
            tempoControl.style.opacity = '1';
          }
          if (pitchControl) {
            pitchControl.disabled = false;
            pitchControl.style.opacity = '1';
          }
          if (frequencyControl) {
            frequencyControl.disabled = false;
            frequencyControl.style.opacity = '1';
          }

          await safePlayerStateChange('pause');
          console.log('[pauseMusic] Pause successful. New state:', currentPlayer?.state);
        } catch (error) {
          console.error('Error pausing music:', error);
          const isPlaying = currentPlayer.state === 1;
          if (playBtn) playBtn.disabled = isPlaying;
          if (pauseBtn) pauseBtn.disabled = !isPlaying;
          if (rewindBtn) rewindBtn.disabled = false;
          if (tempoControl) {
            tempoControl.disabled = isPlaying;
            tempoControl.style.opacity = isPlaying ? '0.5' : '1';
          }
          if (pitchControl) {
            pitchControl.disabled = isPlaying;
            pitchControl.style.opacity = isPlaying ? '0.5' : '1';
          }
          if (frequencyControl) {
            frequencyControl.disabled = isPlaying;
            frequencyControl.style.opacity = isPlaying ? '0.5' : '1';
          }
        } finally {
          setButtonLoading(pauseBtn, false);
        }
      }

      // Update rewind function
      async function rewind() {
        console.log('[rewind] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer) {
          console.log('[rewind] Aborted (no player).');
          return;
        }

        if (rewindBtn) setButtonLoading(rewindBtn, true);
        
        try {
          // Disable all controls during rewind
          if (playBtn) playBtn.disabled = true;
          if (pauseBtn) pauseBtn.disabled = true;
          if (rewindBtn) rewindBtn.disabled = true;
          if (tempoControl) {
            tempoControl.disabled = true;
            tempoControl.style.opacity = '0.5';
          }
          if (pitchControl) {
            pitchControl.disabled = true;
            pitchControl.style.opacity = '0.5';
          }
          if (frequencyControl) {
            frequencyControl.disabled = true;
            frequencyControl.style.opacity = '0.5';
          }

          // Store current state
          const wasPlaying = currentPlayer.state === 1;
          
          // Clear any existing intervals first
          clearPlaybackInterval();

          // Stop all current sounds and clear audio buffers
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            } catch (e) {
              console.warn('[rewind] Error clearing audio:', e);
            }
          }

          // Call the player's rewind method
          try {
            await safePlayerStateChange('rewind');
            console.log('[rewind] Player rewind successful');
          } catch (e) {
            console.warn('[rewind] Error during player rewind:', e);
            
            // Fallback manual rewind
            await safePlayerStateChange('stop');
            
            // Clear audio buffers again after stop
            if (currentOutput) {
              try {
                if (typeof currentOutput.stopAllSounds === 'function') {
                  await currentOutput.stopAllSounds();
                }
                if (typeof currentOutput.clear === 'function') {
                  await currentOutput.clear();
                }
              } catch (e) {
                console.warn('[rewind] Error clearing audio during fallback:', e);
              }
            }

            // Small delay to ensure audio buffers are cleared
            await new Promise(resolve => setTimeout(resolve, 50));
            
            if (typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(0);
            }
            
            // Reset renderer state
            const renderer = currentPlayer.renderer;
            if (renderer) {
              if (typeof renderer.resetCursor === 'function') {
                await renderer.resetCursor();
              }
              if (typeof renderer.render === 'function') {
                await renderer.render();
              }
              if (typeof renderer.updateCursor === 'function') {
                await renderer.updateCursor(0);
              }
            }
          }

          // Scroll to beginning
          const firstSystem = document.querySelector('g.system');
          if (firstSystem) {
            firstSystem.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }

          // Reset button states
          if (playBtn) playBtn.disabled = false;
          if (pauseBtn) pauseBtn.disabled = true;
          if (rewindBtn) rewindBtn.disabled = false;
          if (tempoControl) {
            tempoControl.disabled = false;
            tempoControl.style.opacity = '1';
          }
          if (pitchControl) {
            pitchControl.disabled = false;
            pitchControl.style.opacity = '1';
          }
          if (frequencyControl) {
            frequencyControl.disabled = false;
            frequencyControl.style.opacity = '1';
          }

          // Small delay before resuming playback if it was playing
          if (wasPlaying) {
            await new Promise(resolve => setTimeout(resolve, 50));
            await playMusic();
          }

          console.log('[rewind] Rewind completed successfully');
        } catch (error) {
          console.error('[rewind] Critical error:', error);
          
          // Emergency recovery
          try {
            await cleanupPlayer();
            if (currentMusicXml) {
              await createNewPlayer(currentMusicXml, currentInstrumentId);
            }
          } catch (e) {
            console.error('[rewind] Recovery failed:', e);
          }
          
          // Reset to safe state
          if (playBtn) playBtn.disabled = false;
          if (pauseBtn) pauseBtn.disabled = true;
          if (rewindBtn) rewindBtn.disabled = false;
          if (tempoControl) {
            tempoControl.disabled = false;
            tempoControl.style.opacity = '1';
          }
          if (pitchControl) {
            pitchControl.disabled = false;
            pitchControl.style.opacity = '1';
          }
          if (frequencyControl) {
            frequencyControl.disabled = false;
            frequencyControl.style.opacity = '1';
          }
        } finally {
          if (rewindBtn) setButtonLoading(rewindBtn, false);
        }
      }

      // Update instrument selection handler
      document.getElementById('instrumentSelector').addEventListener('change', async (event) => {
        const selectedInstrumentId = event.target.value;
        if (!selectedInstrumentId) return; // Skip if no instrument selected

        try {
          console.log('[instrumentSelector.onChange] Changing instrument to:', selectedInstrumentId);
          
          // Show loading states
          setInstrumentSelectorLoading(true);
          setButtonLoading(playBtn, true);
          
          // Disable all controls during instrument change
          playBtn.disabled = true;
          pauseBtn.disabled = true;
          rewindBtn.disabled = true;

          // Store current playback state
          const wasPlaying = currentPlayer && currentPlayer.state === 1;
          const currentTime = currentPlayer ? currentPlayer.currentTime : 0;

          // Clean up current state
          await cleanupPlayer();

          // Initialize new instrument
          await initializeSoundFont(selectedInstrumentId, true);
          
          // Create new player with stored MusicXML
          if (currentMusicXml) {
            const player = await createNewPlayer(currentMusicXml, selectedInstrumentId);
            
            // Restore playback position if needed
            if (currentTime > 0) {
              await player.seek(currentTime);
            }

            // Resume playback if it was playing
            if (wasPlaying) {
              await playMusic();
            }
          }
          
          // Reset button states after successful change
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          const feedback = document.getElementById('feedback');
          feedback.className = 'success';
          feedback.textContent = 'Instrument changed successfully!';
        } catch (error) {
          console.error('Error changing instrument:', error);
          
          // Clean up on error
          await cleanupPlayer();
          
          // Reset to default state
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          const feedback = document.getElementById('feedback');
          feedback.className = 'error';
          feedback.textContent = `Error changing instrument: ${error.message}`;
        } finally {
          // Hide loading states
          setInstrumentSelectorLoading(false);
          setButtonLoading(playBtn, false);
        }
      });

      // Add tempo, pitch, and frequency control handlers
      pitchControl.addEventListener('input', async (event) => {
        const semitones = parseInt(event.target.value);
        pitchValue.textContent = semitones;
        
        if (!currentPlayer) return;

        try {
          // Store current state
          const wasPlaying = currentPlayer.state === 1;
          const currentPosition = currentPlayer.position || 0;
          const frequency = parseInt(frequencyControl.value);
          const combinedPitch = Math.pow(2, (semitones + (frequency - 440) / 12) / 12);

          if (wasPlaying) {
            // If playing, we need to pause, update pitch, and resume
            await currentPlayer.pause();
            
            // Clear any pending sounds
            if (currentOutput) {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            }

            // Update pitch
            currentPlayer.pitch = combinedPitch;
            currentPitchSettings.semitones = semitones;

            // Small delay to ensure changes take effect
            await new Promise(resolve => setTimeout(resolve, 30));

            // Resume from current position
            if (currentPosition > 0 && typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(currentPosition);
            }
            await currentPlayer.play();
          } else {
            // If not playing, reinitialize the player with new pitch
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector.value || '0';
            
            // Store current position
            const position = currentPlayer.position || 0;
            
            // Clean up current state
            await cleanupPlayer();
            
            // Initialize new player with current settings
            await initializeSoundFont(selectedInstrumentId, true);
            await createNewPlayer(currentMusicXml, selectedInstrumentId);
            
            // Apply pitch and restore position
            currentPlayer.pitch = combinedPitch;
            currentPitchSettings.semitones = semitones;
            if (position > 0 && typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(position);
            }
          }
        } catch (error) {
          console.error('Error updating pitch:', error);
          try {
            if (currentPlayer && currentPlayer.state === 1) {
              await currentPlayer.play();
            }
          } catch (e) {
            console.warn('Failed to recover player state:', e);
          }
        }
      });

      // Frequency control handler
      frequencyControl.addEventListener('input', async (event) => {
        const frequency = parseInt(event.target.value);
        frequencyValue.textContent = frequency;
        
        if (!currentPlayer) return;

        try {
          // Store current state
          const wasPlaying = currentPlayer.state === 1;
          const currentPosition = currentPlayer.position || 0;
          const semitones = parseInt(pitchControl.value);
          const combinedPitch = Math.pow(2, (semitones + (frequency - 440) / 12) / 12);

          if (wasPlaying) {
            // If playing, we need to pause, update pitch, and resume
            await currentPlayer.pause();
            
            // Clear any pending sounds
            if (currentOutput) {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            }

            // Update pitch
            currentPlayer.pitch = combinedPitch;
            currentPitchSettings.frequency = frequency;

            // Small delay to ensure changes take effect
            await new Promise(resolve => setTimeout(resolve, 30));

            // Resume from current position
            if (currentPosition > 0 && typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(currentPosition);
            }
            await currentPlayer.play();
          } else {
            // If not playing, reinitialize the player with new pitch
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector.value || '0';
            
            // Store current position
            const position = currentPlayer.position || 0;
            
            // Clean up current state
            await cleanupPlayer();
            
            // Initialize new player with current settings
            await initializeSoundFont(selectedInstrumentId, true);
            await createNewPlayer(currentMusicXml, selectedInstrumentId);
            
            // Apply pitch and restore position
            currentPlayer.pitch = combinedPitch;
            currentPitchSettings.frequency = frequency;
            if (position > 0 && typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(position);
            }
          }
        } catch (error) {
          console.error('Error updating frequency:', error);
          try {
            if (currentPlayer && currentPlayer.state === 1) {
              await currentPlayer.play();
            }
          } catch (e) {
            console.warn('Failed to recover player state:', e);
          }
        }
      });

      // Register Service Worker
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js')
            .then(registration => {
              console.log('ServiceWorker registration successful:', registration.scope);
            })
            .catch(error => {
              console.log('ServiceWorker registration failed:', error);
            });
        });
      }

      // Add to Home Screen prompt handler
      let deferredPrompt;
      window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent Chrome 67 and earlier from automatically showing the prompt
        e.preventDefault();
        // Stash the event so it can be triggered later
        deferredPrompt = e;
        // Show the install button or prompt
        showInstallPromotion();
      });

      function showInstallPromotion() {
        // You can add your own UI element to trigger the install prompt
        const installButton = document.createElement('button');
        installButton.textContent = 'Install App';
        installButton.className = 'install-button';
        installButton.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 1001;
          background: var(--primary-color);
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          display: none;
        `;
        document.body.appendChild(installButton);

        // Show the button
        installButton.style.display = 'block';

        installButton.addEventListener('click', async () => {
          // Hide the button
          installButton.style.display = 'none';
          // Show the prompt
          deferredPrompt.prompt();
          // Wait for the user to respond to the prompt
          const { outcome } = await deferredPrompt.userChoice;
          console.log(`User response to the install prompt: ${outcome}`);
          // Clear the deferredPrompt
          deferredPrompt = null;
        });
      }

      // Create toast container
      const toastContainer = document.createElement('div');
      toastContainer.className = 'toast-container';
      document.body.appendChild(toastContainer);

      // Error handling function
      function showError(message, duration = 5000) {
        const toast = document.createElement('div');
        toast.className = 'error-toast';
        toast.innerHTML = `
          <div class="error-icon">⚠️</div>
          <div class="error-message">${message}</div>
          <button class="close-toast">×</button>
        `;
        
        toastContainer.appendChild(toast);
        
        // Add slide-in animation
        requestAnimationFrame(() => {
          toast.style.transform = 'translateX(0)';
          toast.style.opacity = '1';
        });
        
        // Close button handler
        toast.querySelector('.close-toast').addEventListener('click', () => {
          removeToast(toast);
        });
        
        // Auto remove after duration
        if (duration > 0) {
          setTimeout(() => {
            removeToast(toast);
          }, duration);
        }
        
        return toast;
      }

      function removeToast(toast) {
        toast.style.transform = 'translateX(100%)';
        toast.style.opacity = '0';
        setTimeout(() => {
          if (toast.parentElement === toastContainer) {
            toastContainer.removeChild(toast);
          }
        }, 300);
      }

      // Show feedback message
      function showFeedback(elementId, message, type) {
        const feedback = document.getElementById(elementId);
        if (!feedback) return;

        feedback.textContent = message;
        feedback.className = `feedback show ${type}`;
        
        if (type === 'loading') {
          const spinner = document.createElement('div');
          spinner.className = 'spinner';
          feedback.insertBefore(spinner, feedback.firstChild);
        }
      }

      // Clear feedback message
      function clearFeedback(elementId) {
        const feedback = document.getElementById(elementId);
        if (!feedback) return;
        
        feedback.textContent = '';
        feedback.className = 'feedback';
      }

      // Handle PDF uploads with enhanced error handling
      async function handlePdfSelect(e) {
        const file = e.target.files[0];
        const convertBtn = document.getElementById('convert-basic-btn');
        
        clearFeedback('pdf-feedback');
        
        if (!file) {
          convertBtn.disabled = true;
          return;
        }

        try {
          console.log('Processing file:', file.name, 'Type:', file.type, 'Size:', file.size);

          // Validate file type
          if (!file.type.includes('pdf') && !file.type.includes('image')) {
            throw new Error('Please select a PDF or image file.');
          }

          // Check file size
          if (file.size > 4 * 1024 * 1024) {
            throw new Error('File too large. Maximum size is 4MB.');
          }

          // Check if PDF is encrypted
          if (file.type.includes('pdf')) {
            showFeedback('pdf-feedback', 'Checking file security...', 'loading');
            console.log('Starting encryption check for:', file.name);
            
            try {
              const isEncrypted = await ApiService.isPdfEncrypted(file);
              console.log('Encryption check result:', isEncrypted);
              
              if (isEncrypted) {
                throw new Error('This PDF appears to be encrypted or password-protected. Please provide an unencrypted PDF file.');
              }
            } catch (encryptError) {
              console.error('Encryption check error:', encryptError);
              throw encryptError;
            }
          }

          showFeedback('pdf-feedback', `Selected: ${file.name}`, 'success');
          convertBtn.disabled = false;

          // Set up conversion button handler
          convertBtn.onclick = async () => {
            try {
              convertBtn.disabled = true;
              showFeedback('pdf-feedback', 'Converting score...', 'loading');
              console.log('Starting conversion for:', file.name);

              const formData = new FormData();
              formData.append('file', file);

              const response = await fetch('http://ec2-54-252-145-103.ap-southeast-2.compute.amazonaws.com:8000/convert', {
                method: 'POST',
                body: formData,
                headers: {
                  'Accept': 'application/xml, application/x-zip'
                }
              });

              console.log('Server response status:', response.status);
              console.log('Response headers:', Object.fromEntries(response.headers.entries()));

              if (!response.ok) {
                let errorMsg = `Conversion failed! Status: ${response.status}`;
                try {
                  const errData = await response.json();
                  console.error('Server error details:', errData);
                  errorMsg = errData.detail || errorMsg;
                } catch (e) {
                  console.warn('Error parsing error response:', e);
                }
                throw new Error(errorMsg);
              }

              const contentType = response.headers.get('Content-Type');
              console.log('Response content type:', contentType);
              
              const blob = await response.blob();
              console.log('Response blob size:', blob.size);
              
              let musicXmlText = '';

              if (contentType?.includes('zip') || contentType?.includes('mxl') || 
                  (blob.size > 0 && (await blob.slice(0, 2).text()) === 'PK')) {
                console.log('Processing ZIP/MXL response');
                
                const { entries } = await window.unzipit.unzip(blob);
                console.log('ZIP entries:', Object.keys(entries));
                let musicXmlEntry;

                if (entries['META-INF/container.xml']) {
                  const containerText = await entries['META-INF/container.xml'].text();
                  const parser = new DOMParser();
                  const containerDoc = parser.parseFromString(containerText, 'application/xml');
                  const rootfilePath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
                  console.log('Root file path:', rootfilePath);
                  
                  if (rootfilePath && entries[rootfilePath]) {
                    musicXmlEntry = entries[rootfilePath];
                  }
                }

                if (!musicXmlEntry) {
                  musicXmlEntry = Object.values(entries).find(entry => 
                    entry.name.endsWith('.musicxml') || entry.name.endsWith('.xml')
                  );
                }

                if (!musicXmlEntry) {
                  throw new Error('No MusicXML file found in the converted package');
                }

                musicXmlText = await musicXmlEntry.text();
                console.log('Successfully extracted MusicXML from package');
              } else {
                musicXmlText = await blob.text();
                console.log('Received direct MusicXML response');
              }

              // Validate the MusicXML
              if (!musicXmlText.trim().startsWith('<?xml') || !musicXmlText.includes('<score-partwise')) {
                console.error('Invalid MusicXML content:', musicXmlText.substring(0, 100));
                throw new Error('Invalid MusicXML received from conversion');
              }

              showFeedback('pdf-feedback', 'Conversion successful! Loading score...', 'loading');
              
              // Get current instrument selection
              const instrumentSelector = document.getElementById('instrumentSelector');
              const selectedInstrumentId = instrumentSelector.value;
              
              console.log('Creating player with instrument:', selectedInstrumentId);
              
              // Create new player with the converted MusicXML
              await createNewPlayer(musicXmlText, selectedInstrumentId || null);
              
              showFeedback('pdf-feedback', 'Score successfully converted and loaded!', 'success');

            } catch (error) {
              console.error('Conversion error:', error);
              showFeedback('pdf-feedback', `Error: ${error.message}`, 'error');
              showError(error.message);
            } finally {
              convertBtn.disabled = false;
            }
          };

        } catch (error) {
          console.error('PDF validation error:', error);
          showFeedback('pdf-feedback', `Error: ${error.message}`, 'error');
          showError(error.message);
          convertBtn.disabled = true;
        }
      }

      // Update event listeners
      document.getElementById('file-input').addEventListener('change', handleFileSelect);
      document.getElementById('pdf-input').addEventListener('change', handlePdfSelect);

      // ... rest of the existing code ...
    </script>
  </body>
</html>
